#lang racket
(define (make-point x y)
      (cons x y))
(define (point? x)
  (and (cons? x) (real? (car x)) (real? (cdr x))))
(define (point-x x)
  (car x))
(define (point-y x)
  (cdr x))
(define (make-vec a b)
  (if (and (point? a) (point? b))
  (cons a b)
  #f))
(define (vect? v)
  (and (cons? v) (point? (car v)) (point? (cdr v))))
( define ( display-point p )
   ( display "(")
   ( display ( point-x p ) )
   ( display ", ")
   ( display ( point-y p ) )
   ( display ")") )
( define ( display-vect v )
   ( display "[")
   ( display-point ( vect-begin v ) )
   ( display ", ")
   ( display-point ( vect-end v ) )
   ( display "]") )
(define (vect-begin v)
  (car v))
(define (vect-end v)
  (cdr v))
(define (square x)
  (* x x))
(define (vect-scale v k)
  (let ([newx (* (point-x (vect-end v)) (sqrt k))]
        [newy (* (point-y (vect-end v)) (sqrt k))])
    (make-vec (vect-begin v) (make-point newx newy))))
(define (vect-translate v p)
  (let* ([newx (+ (point-x (vect-end v)) (point-x p))]
        [newy (+ (point-y (vect-end v)) (point-y p))]
        [newP (make-point newx newy)])
        (make-vec p newP)))
(define (vect-length v)
  (let ([a1 (- (point-x (vect-end v)) (point-x (vect-begin v)))]
        [a2 (- (point-y (vect-end v)) (point-y (vect-begin v)))])
    (sqrt (+ (square a1) (square a2)))))
;;zadanie 3
(define (reverse xs)
  (if (null? xs)
      null
      (append (reverse (cdr xs)) (list (car xs)))))
(define (reverse-it xs)
  (define (iter i x)
  (if (= i (length xs))
      null
      (append (iter (+ i 1) (cdr x)) (list (car x)))))
  (iter 0 xs))
;;zadanie 4
(define (insert xs n)
  (cond
    ((null? n) (list xs))
    ((null? xs) (list n))
    ((< n (car xs)) (cons n xs))
    (else (cons (car xs) (insert (cdr xs) n)))))
(define (insert-sort xs)
  (cond
    ((null? xs) null)
    (else (insert (insert-sort (cdr xs)) (car xs)))))
;;cwiczenia
(define (map f xs)
  (if (null? xs)
      null
      (cons (f (car xs)) (map f (cdr xs)))))
(define (filter cond xs)
  (if (null? xs)
      null
      (if (cond (car xs))
          (cons (car xs) (filter cond (cdr xs)))
          (filter cond (cdr xs)))))
(define (condi x)
  (< x 2))